# Задание 10.3. Стратегии обеспечения целостности данных

## Механизмы целостности

**1. Hinted Handoff (HH):** Если нода недоступна при записи, координатор сохраняет "подсказку" и потом автоматически доставляет запись на восстановившуюся ноду.

**2. Read Repair:** При чтении сравниваем данные между репликами. Если нашли расхождения, обновляем отстающие реплики в фоне.

**3. Anti-Entropy Repair:** Планово обмениваемся Меркле-деревьями между нодами, чтобы найти все расхождения. Не зависит от запросов клиентов.

## Применение стратегий по сущностям

### 1. Заказы (Orders)
- **Hinted Handoff:** Включён — нельзя терять заказы
- **Read Repair:** 0.1  — заказы читают часто, расхождения будут найдены
- **Anti-Entropy Repair:** Ежедневно (инкрементально) — обязателен для критичных данных
- **CL:** `LOCAL_QUORUM`  гарантируем согласованность
- **Почему так:** Заказы критичны, нельзя терять. Умеренный Read Repair не сильно увеличивает задержку, но подравнивает данные.

### 2. Товары (Products)
- **Hinted Handoff:** Включён — важно не терять обновления
- **Read Repair:** 0.05  — для каталога;
- **Anti-Entropy Repair:** Еженедельно
- **CL:** `LOCAL_QUORUM` (write), `LOCAL_ONE` (read) — для каталога; для обновления остатков можно использовать LWT с `SERIAL`
- **Почему так:** Каталог читают часто, но обновляют редко — расхождения редки. Остатки обновляют часто — нужен контроль через LWT или событийную модель.

### 3. Корзины (Carts)
- **Hinted Handoff:** Включён — пользователь не должен потерять добавленные товары
- **Read Repair:** 0.0 (выключен) — корзина меняется очень часто, накладные расходы на каждое чтение невыгодны
- **Anti-Entropy Repair:** Еженедельно (не критично, TTL сам очистит расхождения)
- **CL:** `LOCAL_ONE` (read), `LOCAL_QUORUM` (write) — минимальная задержка важнее
- **Почему так:** Корзина меняется постоянно, допустимы редкие расхождения на доли секунды. TTL автоматически решает проблему для неактивных корзин.

