# Задание 10.2. Концептуальная модель данных с partition и cluster keys

## 1. Заказы (Orders)

**Таблица: orders**
- Partition Key: `(geo_zone, customer_id)` — как в MongoDB `{ geo: 1, customerId: 1 }`
- Cluster Key: `order_id` (UUID) — как `orderId: "hashed"` для равномерного распределения
- Поля: order_id, customer_id, created_at, items, status, total_amount, geo_zone, updated_at

**Почему так:**
- Partition Key `(geo_zone, customer_id)`:
  - Как в MongoDB — распределяем по геозоне, группируем по клиенту
  - При поиске обычно знаем геозону — сразу идём в нужную партицию
  - Все заказы клиента в одной геозоне в одной партиции
- Cluster Key `order_id`:
  - UUID распределяет равномерно внутри партиции
  - Не будет "горячих" партиций даже у активных клиентов
  - Можем быстро найти заказ по `(geo_zone, customer_id, order_id)`

**Как избегаем "горячих" партиций:**
- Геозона распределяет нагрузку по регионам
- UUID `order_id` распределяет равномерно внутри партиции
- Если клиент в одной геозоне делает очень много заказов, можно добавить шардинг: `(geo_zone, customer_id, customer_shard)`

**Что будет при изменении кластера:**
- С vnodes перераспределение происходит автоматически
- Добавляем/убираем ноды — решардинг не нужен

## 2. Товары (Products)

**Таблица: products**
- Partition Key: `(category)`
- Cluster Keys: `price`, `product_id` — как `{ price: 1, _id: "hashed" }`
- Поля: product_id, name, category, price, stock_by_geo, attributes, updated_at

**Почему так:**
- Partition Key `(category, category_shard)`:
  - Когда запрашиваем категорию, читаем все шарды параллельно и склеиваем на приложении
- Cluster Keys `price, product_id`:
  - Сортировка по цене для фильтрации по диапазону
  - `product_id` (UUID) даёт уникальность и равномерное распределение
  - Запросы работают быстро: `WHERE category = ? AND category_shard = ? AND price >= ? AND price <= ?`

**Как избегаем "горячих" партиций:**
- Шардинг категорий — главное решение для популярных категорий
- Можно увеличить количество шардов при росте нагрузки
- `product_id` (UUID) распределяет равномерно внутри партиции

**Что будет при изменении кластера:**
- С vnodes перераспределение автоматическое
- Шардинг по категориям изолирует изменения — добавление шарда не трогает существующие

## 3. Корзины (Carts)

**Таблица: carts**
- Partition Key: `owner`
- Cluster Keys: `status`, `cart_id` 
- Поля: cart_id, owner (user_id или session_id), status, items (LIST), created_at, updated_at, expires_at
- TTL: через expires_at

**Почему так:**
- Partition Key `owner`:
  - Все корзины владельца в одной партиции
  - Работает и для user_id, и для session_id
- Cluster Keys `status, cart_id`:
  - Можно хранить несколько корзин (активная, заказанная, брошенная)
  - Быстро находим активную корзину: `WHERE owner = ? AND status = 'active'`
  - `cart_id` (UUID) даёт уникальность

**Как избегаем "горячих" партиций:**
- Если используем UUID для `owner`, распределение будет равномерным
- Партиция растёт только с количеством корзин владельца (обычно немного)
- TTL через expires_at автоматически удаляет неактивные корзины

**Что будет при изменении кластера:**
- Партиции небольшие (обычно несколько корзин на владельца) — стриминг быстрый
- TTL упрощает управление данными

## Стратегия репликации

- NetworkTopologyStrategy: DC1: 3 реплики, DC2: 3 реплики
- **Consistency Levels:**
  - Заказы: `LOCAL_QUORUM` (write/read) — баланс между согласованностью и задержкой
  - Товары: `LOCAL_ONE` (read), `LOCAL_QUORUM` (write); для обновления остатков можно использовать LWT с `SERIAL`
  - Корзины: `LOCAL_ONE` (read), `LOCAL_QUORUM` (write) — минимальная задержка важнее

